<pre>// Chap8STL_Demos.cpp

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include "../Chapter7-Display/Chap7Display.h"

template&lt;typename Cont, typename Op&gt;
void doProc(Cont c, Op op) {
  std::for_each(c.begin(), c.end(), op);
}

//template&lt;typename C, typename Op&gt;
//using FP = void(*)(typename C::iterator, typename C::iterator, Op);
//
//template&lt;typename Cont, typename Op&gt;
//void doProc(Cont c, FP&lt;Cont,Op&gt; algo, Op op) {
//  algo(c.begin(), c.end(), op);
//  //std::for_each(c.begin(), c.end(), op);
//}

template&lt;typename Cont, typename Algo, typename Op&gt;
void doProc(Cont c, Algo algo, Op op) {
  algo(c.begin(), c.end(), op);
  //std::for_each(c.begin(), c.end(), op);
}

template&lt;typename V&gt;
auto op = [](V v) {
  static bool first = true;
  if (first) {
    std::cout &lt;&lt; "\n  " &lt;&lt; v;
    first = false;
  }
  else {
    std::cout &lt;&lt; ", " &lt;&lt; v;
  }
};

template&lt;typename V&gt;
class Op {
public:
  void operator()(V v) {
    if (first) {
      std::cout &lt;&lt; "\n  " &lt;&lt; v;
      first = false;
    }
    else {
      std::cout &lt;&lt; ", " &lt;&lt; v;
    }
  }
private:
  bool first = true;
};

template&lt;typename C&gt;
bool contains(C c, typename C::value_type v) {
  typename C::iterator iter = std::find(c.begin(), c.end(), v);
  return iter != c.end();
}

template&lt;typename C&gt;
void show(C&amp; c) {
  //putline(1, "  ");
  std::cout &lt;&lt; "  ";
  for_each(c.begin(), c.end(), Op&lt;typename C::value_type&gt;());
}

template&lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;

template&lt;typename T&gt;
using Lst = std::list&lt;T&gt;;

template&lt;typename T&gt;
using iterator = typename std::vector&lt;T&gt;::iterator;

template&lt;typename C&gt;
struct Range {
  Range(C&amp; c, Op&lt;typename C::value_type&gt; op_) : op(op_) {
    first = c.begin();
    last = c.end();
  }
  typename C::iterator first;
  typename C::iterator last;
  Op&lt;typename C::value_type&gt; op;
};

template&lt;typename C&gt;
void foreach(Range&lt;C&gt; rng) {
  std::for_each(rng.first, rng.last, rng.op);
}


int main() {

  displayDemo("-- traditional algo use --");
  Vec&lt;int&gt; vecInt{ 1, 2, 3, 4, 5 };
  std::for_each(vecInt.begin(), vecInt.end(), Op&lt;int&gt;());

  displayDemo("\n  -- using generic synonyms --");
  Range&lt;Vec&lt;int&gt;&gt; rVI(vecInt, Op&lt;int&gt;());
  //std::cout &lt;&lt; "\n  " &lt;&lt; reinterpret_cast&lt;long long&gt;(vecInt.begin()._Ptr);
  //std::cout &lt;&lt; "\n  " &lt;&lt; reinterpret_cast&lt;long long&gt;(rVI.first._Ptr);
  //std::cout &lt;&lt; "\n  " &lt;&lt; reinterpret_cast&lt;long long&gt;(vecInt.end()._Ptr);
  //std::cout &lt;&lt; "\n  " &lt;&lt; reinterpret_cast&lt;long long&gt;(rVI.last._Ptr);
  //std::for_each(rVI.first, rVI.last, rVI.op);
  std::for_each(rVI.first, rVI.last, rVI.op);
  foreach(rVI);

  displayDemo("\n  -- using synonyms --");
  auto first1 = vecInt.begin();
  auto last1 = vecInt.end();
  auto rng1 = std::pair{ first1, last1 };
  auto slop1 = Op&lt;int&gt;();
  auto forEachOne1 = [](decltype(first1) f, decltype(last1) l, decltype(slop1) s) {
    for_each(f, l, s);
  };
  forEachOne1(first1, last1, slop1);

  Lst&lt;double&gt; lstDbl{ 1.0, -0.5, 0.0, 0.5 };
  auto first2 = lstDbl.begin();
  auto last2 = lstDbl.end();
  auto rng2 = std::pair{ first2, last2 };
  auto slop2 = Op&lt;double&gt;();
  auto forEachOne2 = [](decltype(first2) f, decltype(last2) l, decltype(slop2) s) {
    for_each(f, l, s);
  };
  forEachOne2(rng2.first, rng2.second, slop2);


  displayDemo("\n  -- all the rest --");
  int val = 3;
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "\n  vecInt contains " &lt;&lt; val &lt;&lt; ": " &lt;&lt; contains(vecInt, val);
  iterator&lt;int&gt; iter = std::find(vecInt.begin(), vecInt.end(), val);
  std::cout &lt;&lt; "\n  found " &lt;&lt; val &lt;&lt; " at location " &lt;&lt; iter - vecInt.begin();
  val = 0;
  std::cout &lt;&lt; "\n  vecInt contains " &lt;&lt; val &lt;&lt; ": " &lt;&lt; contains(vecInt, val);

  displayDemo("\n  -- copy with ostream_inserter --");
  auto outIter = std::ostream_iterator&lt;int&gt;(std::cout, " ");
  putline(1, "  ");
  std::copy(vecInt.begin(), vecInt.end(), outIter);

  displayDemo("\n  -- copy with back_inserter --");
  Vec&lt;int&gt; dstVec;
  auto binserter = std::back_inserter(dstVec);
  auto begin = [&amp;vecInt]() { return vecInt.begin(); };
  auto end = [&amp;vecInt]() { return vecInt.end(); };
  std::copy(begin(), --end(), binserter);
  show(dstVec);

  displayDemo("\n  -- copy with inserter --");
  auto inserter = std::inserter(dstVec, ++++dstVec.begin());
  std::copy(begin(), end(), inserter);
  show(dstVec);

  putline();
  Vec&lt;double&gt; vecDbl{ 1.0, -1.0, 0.5 };
  std::list&lt;int&gt; listInt{ 1, 2, 3, 4, 5 };
  doProc(vecInt, Op&lt;int&gt;());
  doProc(vecDbl, op&lt;double&gt;);
  doProc(listInt, Op&lt;int&gt;());

  //doProc(
  //  vecInt, 
  //  std::for_each&lt;
  //    decltype(vecInt)::iterator, 
  //    decltype(vecInt)::iterator, 
  //    decltype(Op&lt;int&gt;())
  //  &gt;,
  //  Op&lt;int&gt;()
  //);

  putline(2);
}
</pre>