<pre>// Chap7TypeTraits.cpp

#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include "..//Display/Display.h"

template&lt;typename T&gt;
struct TypeRep {
  using type = T;
};

template&lt;typename T, T v&gt;
struct ValueRep {
  static constexpr T value = v;
};

template&lt;typename T, T v&gt;
struct ExpressionRep {
  using type = T;
  static constexpr T value = v;
  constexpr operator T() { return v; }
};

template&lt;typename T, T v&gt;
struct ExpRep2 {
  using type = T;
  static constexpr T value = v;
  constexpr operator T() { return v; }
  static constexpr T get() { return v; }
  static constexpr T addOne() { return (v + 1); }
  static constexpr T subOne() { return (v - 1); }
};

template&lt;typename T, T v&gt;
using integral_constant_t = typename std::integral_constant&lt;T, v&gt;::type;

template&lt;typename T, T v&gt;
auto integral_constant_v = std::integral_constant&lt;T, v&gt;::value;

template&lt;typename T&gt;
struct is_void : std::false_type {};

template&lt;&gt;
struct is_void&lt;void&gt; : std::true_type {};

// https://stackoverflow.com/questions/9407367/determine-if-a-type-is-an-stl-container-at-compile-time/31105859#31105859

namespace impl {
  template&lt;typename T&gt; struct is_vector :std::false_type {};
  template &lt;typename... Args&gt; struct is_vector &lt; std::vector&lt;Args...&gt;&gt; :std::true_type {};
}
template&lt;typename T&gt; struct is_vector {
  static constexpr bool const value = impl::is_vector&lt;std::decay_t&lt;T &gt;&gt; ::value;
};

template &lt;class T,
  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value,
  T&gt;::type * = nullptr
&gt;
void do_stuff(T&amp; t) {
  std::cout &lt;&lt; "\n  doing integral stuff with type " &lt;&lt; typeid(t).name();
}

template &lt;class T,
  typename std::enable_if&lt;std::is_class&lt;T&gt;::value,
  T&gt;::type * = nullptr
&gt;
void do_stuff(T&amp; t) {
  std::cout &lt;&lt; "\n  doing class stuff with type " &lt;&lt; typeid(t).name();
}

int main() {

  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(TypeRep&lt;double&gt;::type).name();

  std::cout &lt;&lt; "\n  " &lt;&lt; ValueRep&lt;int, 3&gt;::value;

  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(ExpressionRep&lt;int, 3&gt;::type).name() &lt;&lt; ", " &lt;&lt; ExpressionRep&lt;int, 3&gt;::value;

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(ExpressionRep&lt;bool, true&gt;::type).name() &lt;&lt; ", " &lt;&lt; ExpressionRep&lt;bool, true&gt;::value;
  
  constexpr int v = 0;
  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(ExpRep2&lt;size_t, v&gt;).name() &lt;&lt; ", " &lt;&lt; ExpRep2&lt;size_t, v&gt;::get();
  std::cout &lt;&lt; "\n  " &lt;&lt; ExpRep2&lt;int, v&gt;::addOne();
  std::cout &lt;&lt; "\n  " &lt;&lt; ExpRep2&lt;int, v&gt;();
  std::cout &lt;&lt; "\n  " &lt;&lt; ExpRep2&lt;int, v&gt;::subOne();
  putline();
  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(std::integral_constant&lt;int, 0&gt;::type).name();
  std::cout &lt;&lt; "\n  " &lt;&lt; std::integral_constant&lt;int, 0&gt;::value;

  std::cout &lt;&lt; "\n  " &lt;&lt; typeid(integral_constant_t&lt;int, 0&gt;).name();
  std::cout &lt;&lt; "\n  " &lt;&lt; integral_constant_v&lt;int, 0&gt;;
  putline();

  std::cout &lt;&lt; "\n  " &lt;&lt; is_void&lt;void&gt;::value;
  std::cout &lt;&lt; "\n  " &lt;&lt; is_void&lt;int&gt;::value;
  
  displayDemo("--- is_vector ---");
  std::cout &lt;&lt; "\n  " &lt;&lt; is_vector&lt;std::vector&lt;int&gt;&gt;::value;
  std::cout &lt;&lt; "\n  " &lt;&lt; is_vector&lt;std::vector&lt;double&gt;&gt;::value;
  std::cout &lt;&lt; "\n  " &lt;&lt; is_vector&lt;std::unordered_map&lt;int, std::string&gt;&gt;::value;

  displayDemo("--- enable_if ---");
  class X {};
  X x;
  int i = 42;
  do_stuff(i);
  do_stuff(x);
  std::string s("a string");
  do_stuff(s);
  std::cout &lt;&lt; "\n\n";
}</pre>